<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Felix&#39;s Blog</title>
  <subtitle>学而不思则罔，思而不学则殆</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://blog.zlf.me/"/>
  <updated>2017-01-03T09:20:52.000Z</updated>
  <id>https://blog.zlf.me/</id>
  
  <author>
    <name>Felix</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Kubernetes系列(一)安装Kubernetes(Kubeadm自动化安装)</title>
    <link href="https://blog.zlf.me/Kubernetes%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%80%EF%BC%89%E5%AE%89%E8%A3%85Kubernetes%EF%BC%88Kubeadm%E8%87%AA%E5%8A%A8%E5%8C%96%E5%AE%89%E8%A3%85%EF%BC%89.html"/>
    <id>https://blog.zlf.me/Kubernetes系列（一）安装Kubernetes（Kubeadm自动化安装）.html</id>
    <published>2017-01-03T08:23:04.000Z</published>
    <updated>2017-01-03T09:20:52.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>Kubernetes是Google开源的容器集群管理系统，其提供应用部署、维护、 扩展机制等功能。</p><h2 id="安装前提条件"><a href="#安装前提条件" class="headerlink" title="安装前提条件"></a>安装前提条件</h2><ul><li>机器操作系统必须是Centos7.x或者Ubuntu 16.04+</li><li>内存均大于1G</li><li>集群内机器网络连通</li></ul><a id="more"></a><h2 id="开始安装（以Centos为例）"><a href="#开始安装（以Centos为例）" class="headerlink" title="开始安装（以Centos为例）"></a>开始安装（以Centos为例）</h2><ol><li><p>安装kubelet和kubeadm（集群内所有机器都需要执行）</p><ul><li><p>添加软件仓库</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">cat &lt;&lt;EOF &gt; /etc/yum<span class="selector-class">.repos</span><span class="selector-class">.d</span>/kubernetes<span class="selector-class">.repo</span></div><div class="line">[kubernetes]</div><div class="line">name=Kubernetes</div><div class="line">baseurl=http:<span class="comment">//yum.kubernetes.io/repos/kubernetes-el7-x86_64</span></div><div class="line">enabled=<span class="number">1</span></div><div class="line">gpgcheck=<span class="number">1</span></div><div class="line">repo_gpgcheck=<span class="number">1</span></div><div class="line">gpgkey=https:<span class="comment">//packages.cloud.google.com/yum/doc/yum-key.gpg</span></div><div class="line">       https:<span class="comment">//packages.cloud.google.com/yum/doc/rpm-package-key.gpg</span></div><div class="line">EOF</div></pre></td></tr></table></figure></li><li><p>关闭Selinux</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">setenforce <span class="number">0</span></div></pre></td></tr></table></figure></li><li><p>安装必要的软件</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">yum <span class="keyword">install</span> -y docker kubelet kubeadm kubectl kubernetes-cni</div><div class="line">systemctl <span class="keyword">enable</span> docker &amp;&amp; systemctl <span class="keyword">start</span> docker</div><div class="line">systemctl <span class="keyword">enable</span> kubelet &amp;&amp; systemctl <span class="keyword">start</span> kubelet</div></pre></td></tr></table></figure></li></ul></li><li><p>确定一台机器为master，并进行初始化 (–pod-network-cidr为第3步安装flannel的分配网络)，留意命令行最后输出的内容，格式如：<code>kubeadm join --token=&lt;token&gt; &lt;master-ip&gt;</code> ，第4步会用到</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">kubeadm init --pod-network-cidr=<span class="number">10.244</span><span class="number">.0</span><span class="number">.0</span>/<span class="number">16</span></div></pre></td></tr></table></figure></li><li><p>安装flannel网络，使得docker跨机连通（也是在master机器上执行）</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">kubectl apply -f https:<span class="regexp">//</span>raw.githubusercontent.com<span class="regexp">/coreos/</span>flannel<span class="regexp">/master/</span>Documentation<span class="regexp">/kube-flannel.yml</span></div></pre></td></tr></table></figure><p>使用<code>kubectl get pods --all-namespaces</code>确保pod都已正常运行。</p></li><li><p>将其它机器加入集群内，命令在第2步已输出<br><code>kubeadm join --token=&lt;token&gt; &lt;master-ip&gt;</code></p></li></ol><h2 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h2><p>kubeadm目前还是处于alpha版本，Google不建议在生产环境使用，但是用于搭建开发环境确实方便多了。<br>下篇文章将会介绍手动配置安装kubernetes集群，敬请期待！</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h2&gt;&lt;p&gt;Kubernetes是Google开源的容器集群管理系统，其提供应用部署、维护、 扩展机制等功能。&lt;/p&gt;&lt;h2 id=&quot;安装前提条件&quot;&gt;&lt;a href=&quot;#安装前提条件&quot; class=&quot;headerlink&quot; title=&quot;安装前提条件&quot;&gt;&lt;/a&gt;安装前提条件&lt;/h2&gt;&lt;ul&gt;&lt;li&gt;机器操作系统必须是Centos7.x或者Ubuntu 16.04+&lt;/li&gt;&lt;li&gt;内存均大于1G&lt;/li&gt;&lt;li&gt;集群内机器网络连通&lt;/li&gt;&lt;/ul&gt;
    
    </summary>
    
      <category term="Kubernetes" scheme="https://blog.zlf.me/categories/Kubernetes/"/>
    
    
      <category term="Docker" scheme="https://blog.zlf.me/tags/Docker/"/>
    
      <category term="Kubernetes" scheme="https://blog.zlf.me/tags/Kubernetes/"/>
    
      <category term="Kubeadm" scheme="https://blog.zlf.me/tags/Kubeadm/"/>
    
  </entry>
  
  <entry>
    <title>基于Openwrt打造NAS以及脱机下载中心</title>
    <link href="https://blog.zlf.me/%E5%9F%BA%E4%BA%8EOpenwrt%E6%89%93%E9%80%A0NAS%E4%BB%A5%E5%8F%8A%E8%84%B1%E6%9C%BA%E4%B8%8B%E8%BD%BD%E4%B8%AD%E5%BF%83.html"/>
    <id>https://blog.zlf.me/基于Openwrt打造NAS以及脱机下载中心.html</id>
    <published>2016-12-30T02:21:54.000Z</published>
    <updated>2016-12-30T15:38:16.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前提条件"><a href="#前提条件" class="headerlink" title="前提条件"></a>前提条件</h2><ul><li><p>一台可以刷Openwrt的路由器，可以参照此列表 <a href="https://wiki.openwrt.org/toh/start" target="_blank" rel="external">https://wiki.openwrt.org/toh/start</a></p></li><li><p>路由器有USB扩展接口</p></li><li><p>一台可以接网线且安装了tftp软件的电脑(mbp不支持网线。。。)</p></li></ul><h2 id="开始刷机-以Netgear系列为例"><a href="#开始刷机-以Netgear系列为例" class="headerlink" title="开始刷机(以Netgear系列为例)"></a>开始刷机(以Netgear系列为例)</h2><ul><li><p>关闭路由器，用小针按住路由器后面的reset，然后打开路由器电源。刚开始会是电源灯在黄色闪烁<br>，然后变成绿色闪烁（进入刷机模式，大概10秒左右），此时可以松开reset。</p></li><li><p>网线连上路由器的一个LAN口，并把电脑IP设置为192.168.1.2，掩码设成255.255.255.0</p></li><li><p>打开命令行，输入以下命令：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">tftp</span> 192<span class="selector-class">.168</span><span class="selector-class">.1</span><span class="selector-class">.1</span></div><div class="line"><span class="selector-tag">set</span> <span class="selector-tag">binary</span> #设置为二进制传输模式</div><div class="line"><span class="selector-tag">put</span> <span class="selector-tag">openwrt-ar71xx-nand-</span>***<span class="selector-class">.img</span></div></pre></td></tr></table></figure></li><li><p>等待路由器刷机重启。</p></li></ul><a id="more"></a><h2 id="支持USB"><a href="#支持USB" class="headerlink" title="支持USB"></a>支持USB</h2><ul><li><p>刷完Openwrt后是不支持USB存储的，所以需要安装对应的驱动。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">opkg <span class="keyword">update</span></div><div class="line">opkg <span class="keyword">install</span> kmod-usb-<span class="keyword">storage</span> kmod-fs-ext4 fdisk</div></pre></td></tr></table></figure><p><strong>在移动硬盘或U盘挂载到USB之前，得确保已经相应的格式成ext4文件系统，否则得用fdisk进行分区以及格式化。</strong></p></li><li><p>使用fdisk查看找到对应的移动硬盘或U盘</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">fdisk <span class="_">-l</span></div></pre></td></tr></table></figure></li><li><p>挂载，假设查看到的是/dev/sda1</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">mkdir -p <span class="regexp">/mnt/u</span>sb</div><div class="line">mount <span class="regexp">/dev/</span>sda1 <span class="regexp">/mnt/u</span>sb</div></pre></td></tr></table></figure></li><li><p>查看是否挂载成功</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">df -h</span></div></pre></td></tr></table></figure></li></ul><h2 id="安装Samba共享文件"><a href="#安装Samba共享文件" class="headerlink" title="安装Samba共享文件"></a>安装Samba共享文件</h2><ul><li><p>安装luci-app-samba，会自动安装其依赖samba-server</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">opkg pupdate</div><div class="line">opkg <span class="keyword">install</span> luci-app-samba</div></pre></td></tr></table></figure></li><li><p>打开路由器管理界面，会在菜单里多一项Services-&gt;Network Shares，进行相关配置，将/mnt/sub开启共享。</p></li></ul><p>至此NAS打造完成，接下来介绍打造脱机下载中心。</p><h2 id="安装Aria2"><a href="#安装Aria2" class="headerlink" title="安装Aria2"></a>安装Aria2</h2><ul><li><p>执行如下命令：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">opkg <span class="keyword">update</span></div><div class="line">opkg <span class="keyword">install</span> aria2</div></pre></td></tr></table></figure></li><li><p>启动Aria2，-D表示进入后台运行</p><figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="comment">aria2c</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">enable</span><span class="literal">-</span><span class="comment">rpc</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">rpc</span><span class="literal">-</span><span class="comment">listen</span><span class="literal">-</span><span class="comment">all=true</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">rpc</span><span class="literal">-</span><span class="comment">allow</span><span class="literal">-</span><span class="comment">origin</span><span class="literal">-</span><span class="comment">all</span> <span class="literal">-</span><span class="comment">D</span></div></pre></td></tr></table></figure></li><li><p>安装UI管理界面， 点击<a href="https://github.com/ziahamza/webui-aria2" target="_blank" rel="external">https://github.com/ziahamza/webui-aria2</a>下载Zip文件包，将其解压后放到路由器/www文件夹内，访问192.168.1.1/webui-aria2（假设路由器管理界面为192.168.1.1），就可管理下载任务了。<br><img src="/uploads/基于Openwrt打造NAS以及脱机下载中心/webui-aria2.png" alt=""></p></li></ul><p>至此就可以方便的共享文件及下载文件了～～</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前提条件&quot;&gt;&lt;a href=&quot;#前提条件&quot; class=&quot;headerlink&quot; title=&quot;前提条件&quot;&gt;&lt;/a&gt;前提条件&lt;/h2&gt;&lt;ul&gt;&lt;li&gt;&lt;p&gt;一台可以刷Openwrt的路由器，可以参照此列表 &lt;a href=&quot;https://wiki.openwrt.org/toh/start&quot;&gt;https://wiki.openwrt.org/toh/start&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;路由器有USB扩展接口&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;一台可以接网线且安装了tftp软件的电脑(mbp不支持网线。。。)&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 id=&quot;开始刷机-以Netgear系列为例&quot;&gt;&lt;a href=&quot;#开始刷机-以Netgear系列为例&quot; class=&quot;headerlink&quot; title=&quot;开始刷机(以Netgear系列为例)&quot;&gt;&lt;/a&gt;开始刷机(以Netgear系列为例)&lt;/h2&gt;&lt;ul&gt;&lt;li&gt;&lt;p&gt;关闭路由器，用小针按住路由器后面的reset，然后打开路由器电源。刚开始会是电源灯在黄色闪烁&lt;br&gt;，然后变成绿色闪烁（进入刷机模式，大概10秒左右），此时可以松开reset。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;网线连上路由器的一个LAN口，并把电脑IP设置为192.168.1.2，掩码设成255.255.255.0&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;打开命令行，输入以下命令：&lt;/p&gt;&lt;figure class=&quot;highlight css&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;selector-tag&quot;&gt;tftp&lt;/span&gt; 192&lt;span class=&quot;selector-class&quot;&gt;.168&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.1&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.1&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;selector-tag&quot;&gt;set&lt;/span&gt; &lt;span class=&quot;selector-tag&quot;&gt;binary&lt;/span&gt; #设置为二进制传输模式&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;selector-tag&quot;&gt;put&lt;/span&gt; &lt;span class=&quot;selector-tag&quot;&gt;openwrt-ar71xx-nand-&lt;/span&gt;***&lt;span class=&quot;selector-class&quot;&gt;.img&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;等待路由器刷机重启。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;
    
    </summary>
    
      <category term="路由器" scheme="https://blog.zlf.me/categories/%E8%B7%AF%E7%94%B1%E5%99%A8/"/>
    
    
      <category term="Openwrt" scheme="https://blog.zlf.me/tags/Openwrt/"/>
    
      <category term="Nas" scheme="https://blog.zlf.me/tags/Nas/"/>
    
      <category term="Aria2" scheme="https://blog.zlf.me/tags/Aria2/"/>
    
  </entry>
  
  <entry>
    <title>给网站加HTTPS以及开启HTTP/2</title>
    <link href="https://blog.zlf.me/%E7%BB%99%E7%BD%91%E7%AB%99%E5%8A%A0HTTPS%E4%BB%A5%E5%8F%8A%E5%BC%80%E5%90%AFHTTP-2.html"/>
    <id>https://blog.zlf.me/给网站加HTTPS以及开启HTTP-2.html</id>
    <published>2016-12-22T07:38:35.000Z</published>
    <updated>2016-12-27T14:52:29.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文操作环境：</p><blockquote><ul><li>CentOS 7</li><li>Docker 1.12.5</li><li>Nginx:1.11.7-alpine</li><li>Let’s Encrypt</li><li>Acme-tiny</li></ul></blockquote><h1 id="HTTP-2"><a href="#HTTP-2" class="headerlink" title="HTTP/2"></a>HTTP/2</h1><h2 id="Nginx支持"><a href="#Nginx支持" class="headerlink" title="Nginx支持"></a>Nginx支持</h2><p>Nginx从1.9.5就已支持Http/2<br><a href="https://www.nginx.com/blog/nginx-1-9-5/" target="_blank" rel="external">Open Source NGINX 1.9.5 Released with HTTP/2 Support</a><br>截止目前Docker Hub上的版本为1.11.7<br><img src="/uploads/给网站加HTTPS以及开启HTTP-2/1.png" alt=""><br><strong>注意：</strong> 从图可以看出有两种Nginx的Image，必须选用alpine版本的，才能顺利开启Http/2。<br>另外一个官方推荐的Image使用Debian Jessie作为底包，其OpenSSL最新版本仅支持到 1.0.1t，但是只有从OpenSSL 1.0.2才开始才开始支持ALPN <a href="https://www.openssl.org/news/openssl-1.0.2-notes.html" target="_blank" rel="external">ALPN support</a>，而其又是支持Http/2协议的必要条件。</p><a id="more"></a><h1 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h1><h2 id="Https大势所趋"><a href="#Https大势所趋" class="headerlink" title="Https大势所趋"></a>Https大势所趋</h2><p>到现在还在争论是否需要https已经是毫无意义的事情了。况且在<code>WWDC 2016</code> 开发者大会上，苹果宣布了一个最后期限：到2017年1月1日App Store中的所有应用都必须启用 App Transport Security安全功能。</p><p>顺便推荐大家可以去看一下Google I/O 2016的视频（Youtube）<br><a href="https://www.youtube.com/watch?v=YMfW1bfyGSY" target="_blank" rel="external">Mythbusting HTTPS: Squashing security’s urban legends - Google I/O 2016</a></p><h2 id="背景知识"><a href="#背景知识" class="headerlink" title="背景知识"></a>背景知识</h2><h3 id="证书类型"><a href="#证书类型" class="headerlink" title="证书类型"></a>证书类型</h3><p>HTTPS 证书分为3类:</p><p>1、 DV 域名验证证书 2、 OV 组织机构验证证书 3、 EV 增强的组织机构验证证书</p><p>一般个人使用DV证书完全够了，浏览器表现为地址栏前会有绿色的小锁。所以本文介绍的也是这个。</p><h3 id="证书有效期"><a href="#证书有效期" class="headerlink" title="证书有效期"></a>证书有效期</h3><p>Let’s Encrypt的证书有效期是90天，原因官方给了一篇解释的文章 <a href="https://letsencrypt.org/2015/11/09/why-90-days.html" target="_blank" rel="external">Why ninety-day lifetimes for certificates?</a>， 他们主要是从两方面考虑：</p><blockquote><ol><li>They limit damage from key compromise and mis-issuance. Stolen keys and mis-issued certificates are valid for a shorter period of time.</li><li>They encourage automation, which is absolutely essential for ease-of-use. If we’re going to move the entire Web to HTTPS, we can’t continue to expect system administrators to manually handle renewals. Once issuance and renewal are automated, shorter lifetimes won’t be any less convenience than longer ones.</li></ol></blockquote><h2 id="生成和使用Let’s-Encrypt证书"><a href="#生成和使用Let’s-Encrypt证书" class="headerlink" title="生成和使用Let’s Encrypt证书"></a>生成和使用Let’s Encrypt证书</h2><h3 id="生成Let’s-Encrypt帐号私钥"><a href="#生成Let’s-Encrypt帐号私钥" class="headerlink" title="生成Let’s Encrypt帐号私钥"></a>生成Let’s Encrypt帐号私钥</h3><p><code>openssl genrsa 4096 &gt; account.key</code></p><h3 id="生成证书请求文件（CSR）"><a href="#生成证书请求文件（CSR）" class="headerlink" title="生成证书请求文件（CSR）"></a>生成证书请求文件（CSR）</h3><ol><li>创建域名私钥文件<br><code>openssl genrsa 4096 &gt; domain.key</code></li><li>根据私钥文件，就可以生成 CSR 文件了(目前Let’s Encrypt不支持泛域名)<figure class="highlight maxima"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">#单个域名</div><div class="line">openssl req -<span class="built_in">new</span> -sha256 -<span class="built_in">key</span> <span class="built_in">domain</span>.<span class="built_in">key</span> -subj <span class="string">"/CN=yoursite.com"</span> &gt; <span class="built_in">domain</span>.csr </div><div class="line">＃多个域名</div><div class="line">openssl req -<span class="built_in">new</span> -sha256 -<span class="built_in">key</span> <span class="built_in">domain</span>.<span class="built_in">key</span> -subj <span class="string">"/"</span> -reqexts SAN -config &lt;(cat /etc/pki/tls/openssl.cnf &lt;(<span class="built_in">printf</span> <span class="string">"[SAN]\nsubjectAltName=DNS:yoursite.com,DNS:www.yoursite.com"</span>)) &gt; <span class="built_in">domain</span>.csr</div></pre></td></tr></table></figure></li></ol><h3 id="进行签名操作"><a href="#进行签名操作" class="headerlink" title="进行签名操作"></a>进行签名操作</h3><p>Let’s Encrypt会在你的服务器上生成一个随机验证文件，再通过创建CSR时指定的域名访问，如果可以访问则表明你对这个域名有控制权。</p><ol><li><p>配置Nginx</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">mkdir</span> -p /var/www/challenges/</div><div class="line"></div><div class="line"><span class="comment">#example for nginx conf</span></div><div class="line">server &#123;</div><div class="line">    <span class="attribute">listen</span> <span class="number">80</span>;</div><div class="line">    <span class="attribute">server_name</span> yoursite.com;</div><div class="line"></div><div class="line">    <span class="attribute">location</span> /.well-known/acme-challenge/ &#123;</div><div class="line">        <span class="attribute">alias</span> /var/www/challenges/;</div><div class="line">        <span class="attribute">try_files</span> <span class="variable">$uri</span> =<span class="number">404</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li><li><p>执行脚本</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">wget https:<span class="comment">//raw.githubusercontent.com/diafygi/acme-tiny/master/acme_tiny.py</span></div><div class="line"></div><div class="line">python acme_tiny<span class="selector-class">.py</span> --account-key account<span class="selector-class">.key</span> --csr domain<span class="selector-class">.csr</span> --acme-dir /var/www/challenges/ &gt; signed.crt</div></pre></td></tr></table></figure></li></ol><h3 id="安装中间证书"><a href="#安装中间证书" class="headerlink" title="安装中间证书"></a>安装中间证书</h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">wget -O - https:<span class="comment">//letsencrypt.org/certs/lets-encrypt-x3-cross-signed.pem &gt; intermediate.pem</span></div><div class="line">cat signed<span class="selector-class">.crt</span> intermediate<span class="selector-class">.pem</span> &gt; chained.pem</div></pre></td></tr></table></figure><h3 id="配置Nginx加入证书"><a href="#配置Nginx加入证书" class="headerlink" title="配置Nginx加入证书"></a>配置Nginx加入证书</h3><p>这个可以参考 <a href="https://mozilla.github.io/server-side-tls/ssl-config-generator/" target="_blank" rel="external">Mozilla SSL Configuration Generator</a>。这里生成的配置文件是业界最佳实践和结果，让 Nginx 打开了各种增加安全性和性能的参数。<br>Example：<br><figure class="highlight nginx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="section">server</span> &#123;</div><div class="line">    <span class="attribute">listen</span> <span class="number">80</span> default_server;</div><div class="line">    <span class="attribute">listen</span> [::]:<span class="number">80</span> default_server;</div><div class="line">    <span class="comment"># Redirect all HTTP requests to HTTPS with a 301 Moved Permanently response.</span></div><div class="line">    <span class="attribute">return</span> <span class="number">301</span> https://<span class="variable">$host</span><span class="variable">$request_uri</span>;</div><div class="line">&#125;</div><div class="line"><span class="section">server</span> &#123;</div><div class="line">    <span class="attribute">listen</span> <span class="number">443</span> ssl http2;</div><div class="line">    <span class="attribute">listen</span> [::]:<span class="number">443</span> ssl http2;</div><div class="line">    <span class="comment"># certs sent to the client in SERVER HELLO are concatenated in ssl_certificate</span></div><div class="line">    <span class="attribute">ssl_certificate</span> /path/to/signed_cert_plus_intermediates;</div><div class="line">    <span class="attribute">ssl_certificate_key</span> /path/to/private_key;</div><div class="line">    <span class="attribute">ssl_session_timeout</span> <span class="number">1d</span>;</div><div class="line">    <span class="attribute">ssl_session_cache</span> shared:SSL:<span class="number">50m</span>;</div><div class="line">    <span class="attribute">ssl_session_tickets</span> <span class="literal">off</span>;</div><div class="line">    <span class="comment"># Diffie-Hellman parameter for DHE ciphersuites, recommended 2048 bits</span></div><div class="line">    <span class="attribute">ssl_dhparam</span> /path/to/dhparam.pem;</div><div class="line">    <span class="comment"># intermediate configuration. tweak to your needs.</span></div><div class="line">    <span class="attribute">ssl_protocols</span> TLSv1 TLSv1.<span class="number">1</span> TLSv1.<span class="number">2</span>;</div><div class="line">    <span class="attribute">ssl_ciphers</span> <span class="string">'ECDHE-ECDSA-CHACHA20-POLY1305:ECDHE-RSA-CHACHA20-POLY1305:ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384:DHE-RSA-AES128-GCM-SHA256:DHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-AES128-SHA256:ECDHE-RSA-AES128-SHA256:ECDHE-ECDSA-AES128-SHA:ECDHE-RSA-AES256-SHA384:ECDHE-RSA-AES128-SHA:ECDHE-ECDSA-AES256-SHA384:ECDHE-ECDSA-AES256-SHA:ECDHE-RSA-AES256-SHA:DHE-RSA-AES128-SHA256:DHE-RSA-AES128-SHA:DHE-RSA-AES256-SHA256:DHE-RSA-AES256-SHA:ECDHE-ECDSA-DES-CBC3-SHA:ECDHE-RSA-DES-CBC3-SHA:EDH-RSA-DES-CBC3-SHA:AES128-GCM-SHA256:AES256-GCM-SHA384:AES128-SHA256:AES256-SHA256:AES128-SHA:AES256-SHA:DES-CBC3-SHA:!DSS'</span>;</div><div class="line">    <span class="attribute">ssl_prefer_server_ciphers</span> <span class="literal">on</span>;</div><div class="line">    <span class="comment"># HSTS (ngx_http_headers_module is required) (15768000 seconds = 6 months)</span></div><div class="line">    <span class="attribute">add_header</span> Strict-Transport-Security max-age=<span class="number">15768000</span>;</div><div class="line">    <span class="comment"># OCSP Stapling ---</span></div><div class="line">    <span class="comment"># fetch OCSP records from URL in ssl_certificate and cache them</span></div><div class="line">    <span class="attribute">ssl_stapling</span> <span class="literal">on</span>;</div><div class="line">    <span class="attribute">ssl_stapling_verify</span> <span class="literal">on</span>;</div><div class="line">    <span class="comment">## verify chain of trust of OCSP response using Root CA and Intermediate certs</span></div><div class="line">    <span class="attribute">ssl_trusted_certificate</span> /path/to/root_CA_cert_plus_intermediates;</div><div class="line">    <span class="attribute">resolver</span> &lt;IP DNS resolver&gt;;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h2 id="测试你的服务器SSL安全性"><a href="#测试你的服务器SSL安全性" class="headerlink" title="测试你的服务器SSL安全性"></a>测试你的服务器SSL安全性</h2><p><a href="https://www.ssllabs.com/ssltest/index.html" target="_blank" rel="external">Qualys SSL Labs</a> 提供了全面的 SSL 安全性测试，填写你的网站域名，给自己的 HTTPS 配置打个分。<br>本博测试结果：<br><img src="/uploads/给网站加HTTPS以及开启HTTP-2/2.png" alt=""></p><h2 id="测试你的网站是否开启Http-2"><a href="#测试你的网站是否开启Http-2" class="headerlink" title="测试你的网站是否开启Http/2"></a>测试你的网站是否开启Http/2</h2><p>在Chrome浏览器中输入：<a href="chrome://net-internals/#http2" target="_blank" rel="external">chrome://net-internals/#http2</a>,然后看HTTP/2 sessions表格里是否出现了你的网站即可。<br><img src="/uploads/给网站加HTTPS以及开启HTTP-2/3.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文操作环境：&lt;/p&gt;&lt;blockquote&gt;&lt;ul&gt;&lt;li&gt;CentOS 7&lt;/li&gt;&lt;li&gt;Docker 1.12.5&lt;/li&gt;&lt;li&gt;Nginx:1.11.7-alpine&lt;/li&gt;&lt;li&gt;Let’s Encrypt&lt;/li&gt;&lt;li&gt;Acme-tiny&lt;/li&gt;&lt;/ul&gt;&lt;/blockquote&gt;&lt;h1 id=&quot;HTTP-2&quot;&gt;&lt;a href=&quot;#HTTP-2&quot; class=&quot;headerlink&quot; title=&quot;HTTP/2&quot;&gt;&lt;/a&gt;HTTP/2&lt;/h1&gt;&lt;h2 id=&quot;Nginx支持&quot;&gt;&lt;a href=&quot;#Nginx支持&quot; class=&quot;headerlink&quot; title=&quot;Nginx支持&quot;&gt;&lt;/a&gt;Nginx支持&lt;/h2&gt;&lt;p&gt;Nginx从1.9.5就已支持Http/2&lt;br&gt;&lt;a href=&quot;https://www.nginx.com/blog/nginx-1-9-5/&quot;&gt;Open Source NGINX 1.9.5 Released with HTTP/2 Support&lt;/a&gt;&lt;br&gt;截止目前Docker Hub上的版本为1.11.7&lt;br&gt;&lt;img src=&quot;/uploads/给网站加HTTPS以及开启HTTP-2/1.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;strong&gt;注意：&lt;/strong&gt; 从图可以看出有两种Nginx的Image，必须选用alpine版本的，才能顺利开启Http/2。&lt;br&gt;另外一个官方推荐的Image使用Debian Jessie作为底包，其OpenSSL最新版本仅支持到 1.0.1t，但是只有从OpenSSL 1.0.2才开始才开始支持ALPN &lt;a href=&quot;https://www.openssl.org/news/openssl-1.0.2-notes.html&quot;&gt;ALPN support&lt;/a&gt;，而其又是支持Http/2协议的必要条件。&lt;/p&gt;
    
    </summary>
    
      <category term="Https" scheme="https://blog.zlf.me/categories/Https/"/>
    
    
      <category term="Https" scheme="https://blog.zlf.me/tags/Https/"/>
    
      <category term="Http/2" scheme="https://blog.zlf.me/tags/Http-2/"/>
    
      <category term="Acme" scheme="https://blog.zlf.me/tags/Acme/"/>
    
      <category term="Let&#39;s Encrypt" scheme="https://blog.zlf.me/tags/Let-s-Encrypt/"/>
    
  </entry>
  
  <entry>
    <title>Docker+Wordpress搭建博客</title>
    <link href="https://blog.zlf.me/Docker-Wordpress%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2.html"/>
    <id>https://blog.zlf.me/Docker-Wordpress搭建博客.html</id>
    <published>2016-12-21T05:42:17.000Z</published>
    <updated>2016-12-27T14:52:29.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文简单介绍一下使用Docker+Wordpress搭建博客步骤：</p><h3 id="安装Docker，以Centos-7为例"><a href="#安装Docker，以Centos-7为例" class="headerlink" title="安装Docker，以Centos 7为例"></a>安装Docker，以Centos 7为例</h3><p>1.添加yum repo<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">tee /etc/yum<span class="selector-class">.repos</span><span class="selector-class">.d</span>/docker<span class="selector-class">.repo</span> &lt;&lt;-<span class="string">'EOF'</span></div><div class="line">[dockerrepo]</div><div class="line">name=Docker Repository</div><div class="line">baseurl=https:<span class="comment">//yum.dockerproject.org/repo/main/centos/7/</span></div><div class="line">enabled=<span class="number">1</span></div><div class="line">gpgcheck=<span class="number">1</span></div><div class="line">gpgkey=https:<span class="comment">//yum.dockerproject.org/gpg</span></div><div class="line">EOF</div></pre></td></tr></table></figure><br>2.安装<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">yum <span class="keyword">install</span> docker-<span class="keyword">engine</span> </div></pre></td></tr></table></figure><br>3.启动<figure class="highlight crmsh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">systemctl <span class="literal">start</span> docker</div></pre></td></tr></table></figure><br><a id="more"></a></p><h3 id="安装Mysql"><a href="#安装Mysql" class="headerlink" title="安装Mysql"></a>安装Mysql</h3><p>MYSQL_ROOT_PASSWORD 指定mysql的root密码<br><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker <span class="keyword">run</span><span class="bash"> --name mysql <span class="_">-e</span> MYSQL_ROOT_PASSWORD=password <span class="_">-d</span> mysql</span></div></pre></td></tr></table></figure></p><h3 id="安装Wordpress，访问80端口"><a href="#安装Wordpress，访问80端口" class="headerlink" title="安装Wordpress，访问80端口"></a>安装Wordpress，访问80端口</h3><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker <span class="keyword">run</span><span class="bash"> --name wordpress --link mysql:mysql -p 80:80 <span class="_">-d</span> wordpress</span></div></pre></td></tr></table></figure><p>That’s All 就是这么简单，你会了么～～</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文简单介绍一下使用Docker+Wordpress搭建博客步骤：&lt;/p&gt;&lt;h3 id=&quot;安装Docker，以Centos-7为例&quot;&gt;&lt;a href=&quot;#安装Docker，以Centos-7为例&quot; class=&quot;headerlink&quot; title=&quot;安装Docker，以Centos 7为例&quot;&gt;&lt;/a&gt;安装Docker，以Centos 7为例&lt;/h3&gt;&lt;p&gt;1.添加yum repo&lt;br&gt;&lt;figure class=&quot;highlight stylus&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;tee /etc/yum&lt;span class=&quot;selector-class&quot;&gt;.repos&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.d&lt;/span&gt;/docker&lt;span class=&quot;selector-class&quot;&gt;.repo&lt;/span&gt; &amp;lt;&amp;lt;-&lt;span class=&quot;string&quot;&gt;&#39;EOF&#39;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;[dockerrepo]&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;name=Docker Repository&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;baseurl=https:&lt;span class=&quot;comment&quot;&gt;//yum.dockerproject.org/repo/main/centos/7/&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;enabled=&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;gpgcheck=&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;gpgkey=https:&lt;span class=&quot;comment&quot;&gt;//yum.dockerproject.org/gpg&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;EOF&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;br&gt;2.安装&lt;figure class=&quot;highlight sql&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;yum &lt;span class=&quot;keyword&quot;&gt;install&lt;/span&gt; docker-&lt;span class=&quot;keyword&quot;&gt;engine&lt;/span&gt; &lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;br&gt;3.启动&lt;figure class=&quot;highlight crmsh&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;systemctl &lt;span class=&quot;literal&quot;&gt;start&lt;/span&gt; docker&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;br&gt;
    
    </summary>
    
      <category term="Docker" scheme="https://blog.zlf.me/categories/Docker/"/>
    
    
      <category term="Docker" scheme="https://blog.zlf.me/tags/Docker/"/>
    
      <category term="Wordpress" scheme="https://blog.zlf.me/tags/Wordpress/"/>
    
  </entry>
  
  <entry>
    <title>前端工具链介绍</title>
    <link href="https://blog.zlf.me/%E5%89%8D%E7%AB%AF%E5%B7%A5%E5%85%B7%E9%93%BE%E4%BB%8B%E7%BB%8D.html"/>
    <id>https://blog.zlf.me/前端工具链介绍.html</id>
    <published>2015-11-20T08:19:07.000Z</published>
    <updated>2016-12-27T14:52:29.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前端近几年给人感觉喷涌"><a href="#前端近几年给人感觉喷涌" class="headerlink" title="前端近几年给人感觉喷涌"></a>前端近几年给人感觉喷涌</h2><p>网上有人说</p><blockquote><p>前端变化有多快？两年前，大家都用Grunt构建，去年用Gulp + Browserify构建，今年用Webpack构建，明年可能会使用纯ES6的构建工具。每变一次，前面的那些工具就全没用，都白学。要知道，这些工具每一个都是软件系统，单单Grunt就有4千个插件，然而全没用了。</p></blockquote><hr><blockquote><p>前端真是太变态了，新技术层出不穷，没开始学就过时了，还没有用grunt，gulp就来了，还没用require.js，webpack就来了，还没学sass，postcss就来了，还没学angular.js，react就来了。。。</p></blockquote><a id="more"></a><h2 id="工具链"><a href="#工具链" class="headerlink" title="工具链"></a>工具链</h2><p>yeoman -&gt; bower -&gt; grunt</p><p><img src="/uploads/前端工具链介绍/yeoman.png" alt=""></p><h3 id="yo是构建项目骨架的工具，类似maven-archetype"><a href="#yo是构建项目骨架的工具，类似maven-archetype" class="headerlink" title="yo是构建项目骨架的工具，类似maven archetype"></a>yo是构建项目骨架的工具，类似maven archetype</h3><ul><li>安装yo<br><code>npm install -g yo</code></li><li>安装一个基本骨架<br>` npm install -g generator-webapp</li><li>接下来运行<br><code>yo webapp</code><br>在该目录下会生成如下文件结构:<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">├── <span class="selector-tag">Gruntfile</span><span class="selector-class">.js</span></div><div class="line">├── <span class="selector-tag">app</span></div><div class="line">│   ├── <span class="selector-tag">apple-touch-icon</span><span class="selector-class">.png</span></div><div class="line">│   ├── <span class="selector-tag">favicon</span><span class="selector-class">.ico</span></div><div class="line">│   ├── <span class="selector-tag">fonts</span></div><div class="line">│   ├── <span class="selector-tag">images</span></div><div class="line">│   ├── <span class="selector-tag">index</span><span class="selector-class">.html</span></div><div class="line">│   ├── <span class="selector-tag">robots</span><span class="selector-class">.txt</span></div><div class="line">│   ├── <span class="selector-tag">scripts</span></div><div class="line">│   │   └── <span class="selector-tag">main</span><span class="selector-class">.js</span></div><div class="line">│   └── <span class="selector-tag">styles</span></div><div class="line">│       └── <span class="selector-tag">main</span><span class="selector-class">.css</span></div><div class="line">├── <span class="selector-tag">bower</span><span class="selector-class">.json</span></div><div class="line">├── <span class="selector-tag">package</span><span class="selector-class">.json</span></div><div class="line">└── <span class="selector-tag">test</span></div><div class="line">    ├── <span class="selector-tag">index</span><span class="selector-class">.html</span></div><div class="line">    └── <span class="selector-tag">spec</span></div><div class="line">        └── <span class="selector-tag">test</span><span class="selector-class">.js</span></div></pre></td></tr></table></figure></li></ul><h3 id="bower是解决依赖管理的，类似于maven解决依赖"><a href="#bower是解决依赖管理的，类似于maven解决依赖" class="headerlink" title="bower是解决依赖管理的，类似于maven解决依赖"></a>bower是解决依赖管理的，类似于maven解决依赖</h3><ul><li>安装bower<br><code>npm install -g bower</code></li><li>安装jquery依赖<br><code>bower install jquery</code></li></ul><p>以上命令就会将jquery库下载到本地，再也不用去每个库的官网下载对应的文件了，是不是方便了很多。bower会有个类似maven pom的文件: bower.json</p><h3 id="grunt是自动化压缩、编译、测试等的工具，还是类似maven。"><a href="#grunt是自动化压缩、编译、测试等的工具，还是类似maven。" class="headerlink" title="grunt是自动化压缩、编译、测试等的工具，还是类似maven。"></a>grunt是自动化压缩、编译、测试等的工具，还是类似maven。</h3><ul><li>安装grunt-cli<br><code>npm install -g grunt-cli</code><br>这个并不是装了grunt，而是装了个可以调用各版本的前台命令工具，类似gcc</li><li>安装grunt<br><code>npm install grunt --save-dev</code><br>save-dev选项会将依赖写进package.json</li></ul><p>至此grunt已经安装在项目中，接下来就可以根据需要添加插件，执行各种task</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前端近几年给人感觉喷涌&quot;&gt;&lt;a href=&quot;#前端近几年给人感觉喷涌&quot; class=&quot;headerlink&quot; title=&quot;前端近几年给人感觉喷涌&quot;&gt;&lt;/a&gt;前端近几年给人感觉喷涌&lt;/h2&gt;&lt;p&gt;网上有人说&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;前端变化有多快？两年前，大家都用Grunt构建，去年用Gulp + Browserify构建，今年用Webpack构建，明年可能会使用纯ES6的构建工具。每变一次，前面的那些工具就全没用，都白学。要知道，这些工具每一个都是软件系统，单单Grunt就有4千个插件，然而全没用了。&lt;/p&gt;&lt;/blockquote&gt;&lt;hr&gt;&lt;blockquote&gt;&lt;p&gt;前端真是太变态了，新技术层出不穷，没开始学就过时了，还没有用grunt，gulp就来了，还没用require.js，webpack就来了，还没学sass，postcss就来了，还没学angular.js，react就来了。。。&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
      <category term="前端" scheme="https://blog.zlf.me/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="Yeoman" scheme="https://blog.zlf.me/tags/Yeoman/"/>
    
      <category term="Bower" scheme="https://blog.zlf.me/tags/Bower/"/>
    
      <category term="Grunt" scheme="https://blog.zlf.me/tags/Grunt/"/>
    
  </entry>
  
  <entry>
    <title>Nexus-5X海淘小记</title>
    <link href="https://blog.zlf.me/Nexus-5X%E6%B5%B7%E6%B7%98%E5%B0%8F%E8%AE%B0.html"/>
    <id>https://blog.zlf.me/Nexus-5X海淘小记.html</id>
    <published>2015-11-03T07:50:51.000Z</published>
    <updated>2016-12-27T14:52:29.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="经过漫长的等待，Nexus-5X终于到手了。"><a href="#经过漫长的等待，Nexus-5X终于到手了。" class="headerlink" title="经过漫长的等待，Nexus 5X终于到手了。"></a>经过漫长的等待，Nexus 5X终于到手了。</h2><p><img src="/uploads/Nexus-5X海淘小记/5x-sweet-mobile.png" alt=""></p><a id="more"></a><h2 id="回顾一下整个历程"><a href="#回顾一下整个历程" class="headerlink" title="回顾一下整个历程"></a>回顾一下整个历程</h2><ul><li><p>Google于太平洋时间2015年9月29号在旧金山举行新品发布会，发布会场所略简陋。<br><img src="/uploads/Nexus-5X海淘小记/nexus5x-launch.jpg" alt=""></p></li><li><p>次日凌晨，Google Store接受预定下单，由于之后Google扣款时间超过七天，导致信用卡拒绝扣款，好在发现了这问题，重新预授权一次即可。<br><img src="/uploads/Nexus-5X海淘小记/nexus5x-gstore.jpg" alt=""></p></li><li><p>Google于10月19号开始发货，比传说中的22号提前了几天，点个赞。<br><img src="/uploads/Nexus-5X海淘小记/nexus5x-fedex.jpg" alt=""></p></li><li><p>转运公司于10月30号开始发往国内。<br><img src="/uploads/Nexus-5X海淘小记/nexus5x-usps.png" alt=""></p></li><li><p>11月2号到达。</p></li></ul><h2 id="开箱照"><a href="#开箱照" class="headerlink" title="开箱照"></a>开箱照</h2><p><img src="/uploads/Nexus-5X海淘小记/125308.jpg" alt=""></p><hr><p><img src="/uploads/Nexus-5X海淘小记/125524.jpg" alt=""></p><hr><p><img src="/uploads/Nexus-5X海淘小记/130422.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;经过漫长的等待，Nexus-5X终于到手了。&quot;&gt;&lt;a href=&quot;#经过漫长的等待，Nexus-5X终于到手了。&quot; class=&quot;headerlink&quot; title=&quot;经过漫长的等待，Nexus 5X终于到手了。&quot;&gt;&lt;/a&gt;经过漫长的等待，Nexus 5X终于到手了。&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;/uploads/Nexus-5X海淘小记/5x-sweet-mobile.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="海淘" scheme="https://blog.zlf.me/categories/%E6%B5%B7%E6%B7%98/"/>
    
    
      <category term="Nexus 5X" scheme="https://blog.zlf.me/tags/Nexus-5X/"/>
    
  </entry>
  
  <entry>
    <title>Commons-Logging和SLF4J介绍</title>
    <link href="https://blog.zlf.me/Commons-Logging%E5%92%8CSLF4J%E4%BB%8B%E7%BB%8D.html"/>
    <id>https://blog.zlf.me/Commons-Logging和SLF4J介绍.html</id>
    <published>2015-10-29T07:04:36.000Z</published>
    <updated>2016-12-27T14:52:29.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="项目说明"><a href="#项目说明" class="headerlink" title="项目说明"></a>项目说明</h2><h3 id="Commons-Logging"><a href="#Commons-Logging" class="headerlink" title="Commons Logging"></a>Commons Logging</h3><blockquote><p>The Apache Commons Logging (JCL) provides a Log interface that is intended to be both light-weight and an independent abstraction of other logging toolkits. It provides the middleware/tooling developer with a simple logging abstraction, that allows the user (application developer) to plug in a specific logging implementation.</p></blockquote><h3 id="SLF4J"><a href="#SLF4J" class="headerlink" title="SLF4J"></a>SLF4J</h3><blockquote><p>The Simple Logging Facade for Java (SLF4J) serves as a simple facade or abstraction for various logging frameworks (e.g. java.util.logging, logback, log4j) allowing the end user to plug in the desired logging framework at deployment time.</p></blockquote><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>通过以上说明可以看出他们两个的目的都是一样的，那就是提供统一的日志API供程序调用，而不用关注底层具体使用的是哪个Log Provider。这样就可以随你喜欢，用Log4j或是Logback。</p><a id="more"></a><h2 id="API说明"><a href="#API说明" class="headerlink" title="API说明"></a>API说明</h2><h3 id="Commons-Logging-Api"><a href="#Commons-Logging-Api" class="headerlink" title="Commons Logging Api"></a>Commons Logging Api</h3><figure class="highlight gauss"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Log</span> <span class="built_in">log</span> ＝ LogFactory.getLog();  </div><div class="line"><span class="built_in">log</span>.<span class="keyword">debug</span>(<span class="string">"log"</span>);</div></pre></td></tr></table></figure><h3 id="SLF4J-Api"><a href="#SLF4J-Api" class="headerlink" title="SLF4J Api"></a>SLF4J Api</h3><figure class="highlight abnf"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Logger logger = LoggerFactory.getLogger()<span class="comment">;  </span></div><div class="line">logger.debug(<span class="string">"log"</span>)<span class="comment">;</span></div></pre></td></tr></table></figure><h3 id="添加具体的Log实现库"><a href="#添加具体的Log实现库" class="headerlink" title="添加具体的Log实现库"></a>添加具体的Log实现库</h3><p>在具体使用时,还需将Log Provider加入到Classpath里,比如Log4j，Logback。</p><h2 id="怎么知道调用哪个实现库的呢"><a href="#怎么知道调用哪个实现库的呢" class="headerlink" title="怎么知道调用哪个实现库的呢"></a>怎么知道调用哪个实现库的呢</h2><p>来看看Commons Logging的源代码，来了解一下是怎么知道究竟调用哪一个Log Provider的。</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//代码在org.apache.commons.logging.impl.LogFactoryImpl.java文件</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">String</span> LOGGING_IMPL_LOG4J_LOGGER = <span class="string">"org.apache.commons.logging.impl.Log4JLogger"</span>;</div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">String</span>[] classesToDiscover = &#123;</div><div class="line">    LOGGING_IMPL_LOG4J_LOGGER,</div><div class="line">    <span class="string">"org.apache.commons.logging.impl.Jdk14Logger"</span>,</div><div class="line">    <span class="string">"org.apache.commons.logging.impl.Jdk13LumberjackLogger"</span>,</div><div class="line">    <span class="string">"org.apache.commons.logging.impl.SimpleLog"</span></div><div class="line">&#125;;    </div><div class="line"><span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">0</span>; i&lt;classesToDiscover.length &amp;&amp; result == <span class="keyword">null</span>; ++i) &#123;</div><div class="line">        result = createLogFromClass(classesToDiscover[i], logCategory, <span class="keyword">true</span>);</div><div class="line">    &#125;</div><div class="line">c = Class.forName(logAdapterClassName, <span class="keyword">true</span>, currentCL);</div></pre></td></tr></table></figure><p>可以看出，Commons Logging会在程序启动后进行试加载，一旦有某个Log Provider在Classpath下，就会加载成功。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;项目说明&quot;&gt;&lt;a href=&quot;#项目说明&quot; class=&quot;headerlink&quot; title=&quot;项目说明&quot;&gt;&lt;/a&gt;项目说明&lt;/h2&gt;&lt;h3 id=&quot;Commons-Logging&quot;&gt;&lt;a href=&quot;#Commons-Logging&quot; class=&quot;headerlink&quot; title=&quot;Commons Logging&quot;&gt;&lt;/a&gt;Commons Logging&lt;/h3&gt;&lt;blockquote&gt;&lt;p&gt;The Apache Commons Logging (JCL) provides a Log interface that is intended to be both light-weight and an independent abstraction of other logging toolkits. It provides the middleware/tooling developer with a simple logging abstraction, that allows the user (application developer) to plug in a specific logging implementation.&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 id=&quot;SLF4J&quot;&gt;&lt;a href=&quot;#SLF4J&quot; class=&quot;headerlink&quot; title=&quot;SLF4J&quot;&gt;&lt;/a&gt;SLF4J&lt;/h3&gt;&lt;blockquote&gt;&lt;p&gt;The Simple Logging Facade for Java (SLF4J) serves as a simple facade or abstraction for various logging frameworks (e.g. java.util.logging, logback, log4j) allowing the end user to plug in the desired logging framework at deployment time.&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 id=&quot;结论&quot;&gt;&lt;a href=&quot;#结论&quot; class=&quot;headerlink&quot; title=&quot;结论&quot;&gt;&lt;/a&gt;结论&lt;/h3&gt;&lt;p&gt;通过以上说明可以看出他们两个的目的都是一样的，那就是提供统一的日志API供程序调用，而不用关注底层具体使用的是哪个Log Provider。这样就可以随你喜欢，用Log4j或是Logback。&lt;/p&gt;
    
    </summary>
    
      <category term="日志" scheme="https://blog.zlf.me/categories/%E6%97%A5%E5%BF%97/"/>
    
    
      <category term="Commons Logging" scheme="https://blog.zlf.me/tags/Commons-Logging/"/>
    
      <category term="SLF4J" scheme="https://blog.zlf.me/tags/SLF4J/"/>
    
  </entry>
  
</feed>
